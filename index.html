<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fasteners Viewer · GitHub Pages</title>
  <style>
    :root { --bg:#0b0c10; --panel:#14161a; --text:#e8ecf1; --muted:#aab4c3; --accent:#6bc1ff; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font: 500 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    header {
      display:flex; gap:10px; align-items:center; padding:10px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
      border-bottom:1px solid rgba(255,255,255,0.08);
      position:sticky; top:0; z-index:4;
    }
    .badge { font-weight:700; color:#111; background:var(--accent); padding:4px 8px; border-radius:10px; }
    .repo { color:var(--muted); }
    .spacer { flex:1; }
    .small { color: var(--muted); font-size: 12px; }
    main {
      display:grid; grid-template-columns: 360px 1fr; gap: 14px;
      height: calc(100% - 58px); padding: 14px;
    }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
    }
    .panel {
      background: var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      overflow: visible; /* ensure dropdowns open fully */
    }
    .row { display:grid; grid-template-columns: 120px 1fr; gap: 10px; align-items:center; margin: 10px 0; }
    label { color:var(--muted); }
    select, button {
      width:100%; background:#0f1116; color:var(--text);
      border:1px solid rgba(255,255,255,0.2); border-radius: 8px; padding:9px 10px;
      outline:none; appearance:auto;
    }
    select:disabled { opacity:0.5; }
    button {
      cursor:pointer; font-weight:700;
    }
    .viewer {
      position: relative; min-height: 480px; height: calc(100vh - 140px);
      background: radial-gradient(80% 80% at 50% 20%, #1a1e24, #0b0c10);
      border-radius: 12px; overflow: hidden; border:1px solid rgba(255,255,255,0.08);
    }
    #threeMount { position:absolute; inset:0; }
    .status { margin-top:8px; color:var(--muted); white-space:pre-wrap; }
    .pill { display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px; background:#10131a; border:1px solid rgba(255,255,255,0.08); }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <div class="badge">Fasteners</div>
    <div class="repo" id="repoName">nimageran/fasteners-viewer</div>
    <div class="spacer"></div>
    <div class="small" id="branchInfo">branch: …</div>
  </header>

  <main>
    <section class="panel">
      <div style="font-weight:700; margin-bottom:8px;">Select fastener</div>

      <div class="row">
        <label for="kindSel">Kind</label>
        <select id="kindSel" disabled>
          <option value="">—</option>
        </select>
      </div>

      <div class="row">
        <label for="familySel">Family</label>
        <select id="familySel" disabled>
          <option value="">—</option>
        </select>
      </div>

      <div class="row">
        <label for="stdSel">Standard</label>
        <select id="stdSel" disabled>
          <option value="">—</option>
        </select>
      </div>

      <div class="grid">
        <div class="row" style="margin:0;">
          <label for="diamSel">Diameter</label>
          <select id="diamSel" disabled><option value="">—</option></select>
        </div>
        <div class="row" style="margin:0;">
          <label for="lenSel">Length</label>
          <select id="lenSel" disabled><option value="">—</option></select>
        </div>
      </div>

      <div style="display:flex; gap:8px; margin-top:10px;">
        <button id="resetBtn" title="Reset view">Reset view</button>
        <a id="downloadLink" class="pill" href="#" download>⬇ Download STL</a>
      </div>

      <div class="status" id="status">Loading repo index…</div>
    </section>

    <section class="viewer">
      <div id="threeMount"></div>
    </section>
  </main>

  <script type="module">
    // === Imports ===
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';
    import { STLLoader } from 'https://unpkg.com/three@0.159.0/examples/jsm/loaders/STLLoader.js';

    // === Config (repo) ===
    const owner = 'nimageran';
    const repo  = 'fasteners-viewer';

    // === DOM ===
    const statusEl = document.getElementById('status');
    const branchInfo = document.getElementById('branchInfo');
    const kindSel = document.getElementById('kindSel');
    const familySel = document.getElementById('familySel');
    const stdSel = document.getElementById('stdSel');
    const diamSel = document.getElementById('diamSel');
    const lenSel = document.getElementById('lenSel');
    const dlLink = document.getElementById('downloadLink');
    const resetBtn = document.getElementById('resetBtn');

    function setStatus(msg) { statusEl.textContent = msg; }

    // === Three.js Viewer ===
    let renderer, scene, camera, controls, currentMesh;
    const mount = document.getElementById('threeMount');

    function init3D() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c10);

      const w = mount.clientWidth || mount.parentElement.clientWidth;
      const h = mount.clientHeight || 500;

      camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
      camera.position.set(80, 80, 120);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(w, h);
      mount.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.07;

      // Lights
      const amb = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(amb);
      const dir1 = new THREE.DirectionalLight(0xffffff, 0.6);
      dir1.position.set(1,1,1);
      scene.add(dir1);
      const dir2 = new THREE.DirectionalLight(0xffffff, 0.3);
      dir2.position.set(-1,-0.5,0.5);
      scene.add(dir2);

      // Ground grid (subtle)
      const grid = new THREE.GridHelper(400, 40, 0x2a2f39, 0x1b1f26);
      grid.position.y = -0.01;
      scene.add(grid);

      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize() {
      if (!renderer) return;
      const w = mount.clientWidth || mount.parentElement.clientWidth;
      const h = mount.clientHeight || 500;
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function clearCurrent() {
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.geometry.dispose();
        currentMesh.material.dispose();
        currentMesh = null;
      }
    }

    function frameObject(obj) {
      // Fit camera to object nicely
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      const maxDim = Math.max(size.x, size.y, size.z);
      const fitDist = maxDim * 1.8;
      const dir = new THREE.Vector3(1, 0.7, 1).normalize();

      camera.position.copy(center.clone().add(dir.multiplyScalar(fitDist)));
      camera.near = maxDim / 100;
      camera.far = maxDim * 100;
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    const loader = new STLLoader();
    async function loadSTL(rawUrl) {
      setStatus('Loading STL…');
      clearCurrent();
      return new Promise((resolve, reject) => {
        loader.load(rawUrl, (geom) => {
          const mat = new THREE.MeshStandardMaterial({ color: 0x9fb7ff, metalness: 0.2, roughness: 0.35 });
          const mesh = new THREE.Mesh(geom, mat);
          // Center geometry to origin for stable controls
          geom.computeBoundingBox();
          const c = geom.boundingBox.getCenter(new THREE.Vector3());
          geom.translate(-c.x, -c.y, -c.z);
          currentMesh = mesh;
          scene.add(mesh);
          frameObject(mesh);
          setStatus('Ready.');
          resolve();
        }, undefined, (err) => {
          setStatus('Failed to load STL (check file/branch).');
          reject(err);
        })
      });
    }

    resetBtn.addEventListener('click', () => {
      if (currentMesh) frameObject(currentMesh);
    });

    // === Data discovery from repo ===
    const API = 'https://api.github.com';
    const RAW = 'https://raw.githubusercontent.com';

    async function getDefaultBranch() {
      const res = await fetch(`${API}/repos/${owner}/${repo}`);
      if (!res.ok) throw new Error('Repo not found');
      const j = await res.json();
      branchInfo.textContent = `branch: ${j.default_branch}`;
      return j.default_branch || 'main';
    }

    async function getTree(branch) {
      const url = `${API}/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('Git tree fetch failed');
      const j = await r.json();
      return j.tree || [];
    }

    function parseFilename(file) {
      // Expect e.g. SocketHead_M10x20_ISO4762.stl  OR  FlatHead_M3x16_ISO10642.stl
      const base = file.replace(/\.stl$/i, '');
      const m = base.match(/^([A-Za-z]+Head)_M(\d+(?:\.\d+)?)x(\d+(?:\.\d+)?)(?:_([A-Za-z0-9]+))?$/i);
      if (!m) return null;
      return {
        familyFromName: m[1],  // SocketHead / FlatHead
        diameter: m[2],        // "10"
        length: m[3],          // "20"
        stdFromName: m[4] || null
      };
    }

    function byNumeric(a,b){ return Number(a)-Number(b); }

    async function buildIndex() {
      const branch = await getDefaultBranch();
      const tree = await getTree(branch);

      setStatus('Indexing STL files…');

      const items = tree.filter(t =>
        t.type === 'blob' &&
        /\.stl$/i.test(t.path) &&
        /\/STL\//i.test(t.path)
      );

      // data[kind][family][standard] => { entries: [{diameter,length,path,rawUrl,name}], diams:Set, lens:Set }
      const data = Object.create(null);

      for (const it of items) {
        const parts = it.path.split('/'); // e.g., Bolts/Socket_Head/ISO4762/STL/SocketHead_M10x20_ISO4762.stl
        if (parts.length < 5) continue;
        const kind = parts[0];            // Bolts (future: Nuts, Washers, …)
        const familyFolder = parts[1];    // Socket_Head or Flat_Head
        const standardFolder = parts[2];  // ISO4762 or ISO10642
        // parts[3] === 'STL'
        const fileName = parts[parts.length-1];

        const parsed = parseFilename(fileName);
        if (!parsed) continue;

        const family = parsed.familyFromName || familyFolder;
        const standard = (parsed.stdFromName && parsed.stdFromName.toUpperCase()) || standardFolder;

        data[kind] ??= Object.create(null);
        data[kind][family] ??= Object.create(null);
        data[kind][family][standard] ??= { entries: [], diams: new Set(), lens: new Set() };

        const entry = {
          diameter: parsed.diameter,
          length: parsed.length,
          path: it.path,
          name: fileName,
          rawUrl: `${RAW}/${owner}/${repo}/${branch}/${it.path}`
        };
        data[kind][family][standard].entries.push(entry);
        data[kind][family][standard].diams.add(parsed.diameter);
        data[kind][family][standard].lens.add(parsed.length);
      }

      // freeze into arrays sorted numerically
      for (const k of Object.keys(data)) {
        for (const f of Object.keys(data[k])) {
          for (const s of Object.keys(data[k][f])) {
            const bucket = data[k][f][s];
            bucket.diamList = Array.from(bucket.diams).sort(byNumeric);
            bucket.lenList = Array.from(bucket.lens).sort(byNumeric);
          }
        }
      }

      return { branch, data };
    }

    // === UI binding ===
    function fillSelect(sel, values, placeholder='—') {
      sel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = ''; opt0.textContent = placeholder;
      sel.appendChild(opt0);
      for (const v of values) {
        const o = document.createElement('option');
        o.value = v; o.textContent = v;
        sel.appendChild(o);
      }
      sel.disabled = values.length === 0;
    }

    let INDEX = null;
    let CURRENT_BUCKET = null;

    function updateKinds() {
      const kinds = Object.keys(INDEX.data).sort();
      fillSelect(kindSel, kinds);
      familySel.disabled = true;
      stdSel.disabled = true;
      diamSel.disabled = true;
      lenSel.disabled = true;
    }

    function onKindChanged() {
      const k = kindSel.value;
      if (!k) {
        fillSelect(familySel, []);
        fillSelect(stdSel, []);
        fillSelect(diamSel, []);
        fillSelect(lenSel, []);
        CURRENT_BUCKET = null;
        return;
      }
      const families = Object.keys(INDEX.data[k]).sort();
      fillSelect(familySel, families);
      fillSelect(stdSel, []);
      fillSelect(diamSel, []);
      fillSelect(lenSel, []);
    }

    function onFamilyChanged() {
      const k = kindSel.value, f = familySel.value;
      if (!k || !f) {
        fillSelect(stdSel, []); fillSelect(diamSel, []); fillSelect(lenSel, []);
        CURRENT_BUCKET = null; return;
      }
      const stds = Object.keys(INDEX.data[k][f]).sort();
      fillSelect(stdSel, stds);
      fillSelect(diamSel, []);
      fillSelect(lenSel, []);
    }

    function onStdChanged() {
      const k = kindSel.value, f = familySel.value, s = stdSel.value;
      if (!k || !f || !s) {
        fillSelect(diamSel, []); fillSelect(lenSel, []);
        CURRENT_BUCKET = null; return;
      }
      CURRENT_BUCKET = INDEX.data[k][f][s];
      fillSelect(diamSel, CURRENT_BUCKET.diamList.map(d => `M${d}`)); // show as M3, M4…
      fillSelect(lenSel, []);
    }

    function onDiamChanged() {
      if (!CURRENT_BUCKET) return;
      const d = (diamSel.value || '').replace(/^M/i, '');
      const lengths = CURRENT_BUCKET.entries
        .filter(e => e.diameter === d)
        .map(e => e.length);
      const unique = Array.from(new Set(lengths)).sort(byNumeric);
      fillSelect(lenSel, unique);
    }

    async function onLenChanged() {
      if (!CURRENT_BUCKET) return;
      const d = (diamSel.value || '').replace(/^M/i, '');
      const L = lenSel.value;
      const hit = CURRENT_BUCKET.entries.find(e => e.diameter === d && e.length === L);
      if (!hit) { setStatus('No STL found for this combination.'); return; }
      dlLink.href = hit.rawUrl;
      await loadSTL(hit.rawUrl);
    }

    // === Init ===
    init3D();

    (async () => {
      try {
        setStatus('Loading repo index…');
        INDEX = await buildIndex();
        setStatus('Index ready. Pick Kind → Family → Standard → Diameter → Length.');
        updateKinds();
        kindSel.disabled = false;
      } catch (e) {
        console.error(e);
        setStatus('Failed to load repo. Check Pages is enabled and the repo is public.');
      }
    })();

    // === Events ===
    kindSel.addEventListener('change', onKindChanged);
    familySel.addEventListener('change', onFamilyChanged);
    stdSel.addEventListener('change', onStdChanged);
    diamSel.addEventListener('change', onDiamChanged);
    lenSel.addEventListener('change', onLenChanged);
  </script>
</body>
</html>
